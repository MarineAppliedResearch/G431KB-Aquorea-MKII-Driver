/**************************************************************************
 * wizchip_port.c
 *
 * Author: Isaac Travers
 * Copyright: (c) 2026 Marine Applied Research & Exploration (MARE)
 * License: MIT
 *
 * Purpose:
 * --------
 * Low-level hardware port for the WIZnet W5500 Ethernet controller.
 *
 * This module binds the WIZnet ioLibrary to STM32 HAL SPI and GPIO.
 * It provides chip select control, reset control, and SPI read/write
 * primitives required by the WIZnet stack.
 *************************************************************************/

#include "wizchip_port.h"
#include "main.h"   // pulls in stm32g431xx.h

#ifdef IR
#undef IR
#endif

#include "wizchip_conf.h"

/* SPI handle generated by CubeMX */
extern SPI_HandleTypeDef hspi3;

/* --------------------------------------------------------------------------
 * Internal state
 * -------------------------------------------------------------------------- */

/* Optional debug logger */
static wizchip_log_fn logger = NULL;

/**
 * wizchip_select
 *
 * Assert the W5500 chip select line.
 *
 * This function is registered with the WIZnet ioLibrary and is called
 * automatically before any SPI transaction begins.
 */
static void wizchip_select(void)
{
    /* Assert chip select before SPI transactions */
	HAL_GPIO_WritePin(SPI3_CS_GPIO_Port, SPI3_CS_Pin, GPIO_PIN_RESET);
}


/**
 * wizchip_deselect
 *
 * Deassert the W5500 chip select line.
 *
 * This function is registered with the WIZnet ioLibrary and is called
 * automatically after an SPI transaction completes.
 */
static void wizchip_deselect(void)
{
    /* Deassert chip select after SPI transactions */
    HAL_GPIO_WritePin(SPI3_CS_GPIO_Port, SPI3_CS_Pin, GPIO_PIN_SET);
}

/* --------------------------------------------------------------------------
 * SPI primitives
 * -------------------------------------------------------------------------- */


/**
 * wizchip_spi_readbyte
 *
 * Read a single byte from the W5500 over SPI.
 *
 * The ioLibrary uses this callback to fetch register and buffer data.
 * A dummy byte is transmitted to generate SPI clock pulses.
 */
static uint8_t wizchip_spi_readbyte(void)
{
    uint8_t tx = 0xFF;
    uint8_t rx = 0;

    /* Clock one byte while reading data from the W5500 */
    //HAL_SPI_TransmitReceive(&hspi1, &tx, &rx, 1, HAL_MAX_DELAY);
    if (HAL_SPI_TransmitReceive(&hspi3, &tx, &rx, 1, 10) != HAL_OK)
        {
            return 0x00;
        }

    return rx;
}


/**
 * wizchip_spi_writebyte
 *
 * Write a single byte to the W5500 over SPI.
 *
 * The ioLibrary uses this callback to send register and buffer data.
 * Any received byte during the transfer is ignored.
 */
static void wizchip_spi_writebyte(uint8_t byte)
{
    uint8_t rx;

    /* Clock one byte into the W5500, discard received data */
    //HAL_SPI_TransmitReceive(&hspi1, &byte, &rx, 1, HAL_MAX_DELAY);
    (void)HAL_SPI_TransmitReceive(&hspi3, &byte, &rx, 1, 10);
}


/**
 * wizchip_port_reset
 *
 * Perform a hardware reset of the W5500.
 *
 * Drives the reset pin low for the minimum required duration, then
 * releases it and waits for the chip to complete internal startup.
 */
void wizchip_port_reset(void)
{
	// Drive reset low to force the chip into reset
	HAL_GPIO_WritePin(SPI3_RESET_GPIO_Port, SPI3_RESET_Pin, GPIO_PIN_RESET);

	// Hold reset long enough to meet W5500 timing requirements
	HAL_Delay(10);

	// Release reset and allow the chip to boot
	HAL_GPIO_WritePin(SPI3_RESET_GPIO_Port, SPI3_RESET_Pin, GPIO_PIN_SET);

	// Wait for internal initialization to complete
	HAL_Delay(100);
}

/* --------------------------------------------------------------------------
 * Public API
 * -------------------------------------------------------------------------- */


/**
 * wizchip_port_set_logger
 *
 * Register a debug logging callback for the port layer.
 *
 * If set, the driver emits high-level status messages during
 * initialization and error conditions. Passing NULL disables logging.
 */
void wizchip_port_set_logger(wizchip_log_fn fn)
{
    logger = fn;
}


/**
 * wizchip_port_init
 *
 * Initialize the W5500 hardware port and verify communication.
 *
 * This function resets the chip, registers SPI and chip-select callbacks
 * with the WIZnet ioLibrary, and confirms the device is present by
 * reading the version register.
 */
bool wizchip_port_init(void)
{
    uint8_t version;

    /* Ensure CS is idle before starting */
    HAL_GPIO_WritePin(SPI3_CS_GPIO_Port, SPI3_CS_Pin, GPIO_PIN_SET);

    /* Reset the W5500 to a known state */
    wizchip_port_reset();

    /* Register chip-select callbacks */
    reg_wizchip_cs_cbfunc(wizchip_select, wizchip_deselect);

    /* Register SPI byte-level callbacks */
    reg_wizchip_spi_cbfunc(wizchip_spi_readbyte, wizchip_spi_writebyte);

    // REQUIRED
    uint8_t txsize[8] = {2,2,2,2,2,2,2,2};
    uint8_t rxsize[8] = {2,2,2,2,2,2,2,2};
    wizchip_init(txsize, rxsize);

    /* Verify communication by reading the version register */

    if (logger)
        logger("Reading VERSIONR");




    version = getVERSIONR();


    if (logger)
    {
        char buf[32];
        snprintf(buf, sizeof(buf), "VERSIONR = 0x%02X\r\n", version);
        logger(buf);
    }


    if (version != 0x04)
    {
        if (logger)
            logger("W5500 version check failed");

        return false;
    }

    if (logger)
        logger("W5500 detected");

    return true;
}

static void wizchip_spi_readburst(uint8_t* pBuf, uint16_t len)
{
    uint8_t tx = 0xFF;
    for (uint16_t i = 0; i < len; i++)
        HAL_SPI_TransmitReceive(&hspi3, &tx, &pBuf[i], 1, HAL_MAX_DELAY);
}

static void wizchip_spi_writeburst(uint8_t* pBuf, uint16_t len)
{
    uint8_t rx;
    for (uint16_t i = 0; i < len; i++)
        HAL_SPI_TransmitReceive(&hspi3, &pBuf[i], &rx, 1, HAL_MAX_DELAY);
}
